RAII, зачем нужно?

void f(int n)
{
    double * p = new double[n];
    ...
    if(...)
        return; // 2. преждевременный выход - возможна утечка нужно вставить delete[] p;
    ...
    // 1. можем профукать при выбросе исключений
    try
    {

    }
    catch (...)
    {
        delete[] p;
        throw; // возбуждаем исключение повторно
    }
    ...
    delete[] p; // 0. можем и его профукать
}

C++ гарантирует:
1) при создании объекта вызывать конструктор
2) при уничтожении объекта вызывать деструктор

по сути, используя вектор, мы ему (объекту) передаём управление своими ресурсами и он сам их 
уничтожает при необходимости

выстрел в ногу используя unique_ptr:
X *p;
p = new X;
std::unique_ptr<X> smart{p};
std::unique_ptr<X> sm{p};
// при удалении unique_ptr мы повредим память двойным удалением

ключевой момент с которого начинается аллокатор - то, что может не быть конструктора по умолчанию у 
пользовательского класса
также это даёт нам возможность создания собственной реализации управления памятью

понятие Vector_base<>
концепция, управляющая неиниц. памятью

понятие unitialize_copy (оставлено для собственного изучения)